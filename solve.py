import sys
import math
import random
from pwn import *

def calc_det(i,j,X):
    """ Calculate the values for the matrix[lattice] """
    a1 = X[i] - X[0]
    b1 = X[i+1] - X[1]
    a2 = X[j] - X[0]
    b2 = X[j+1] - X[1]

    """ Calculate the determinant """
    det = a1*b2 - a2*b1
    return abs(det)

def GCD(a,b):
    """ Euclidean Algo"""
    a = abs(a)
    b = abs(b)
    while a:
            a,b = long(b%a),a
    return b

def modInverse(a, m):

    if GCD(a, m) != 1:
        return None # no mod inverse if a & m aren't relatively prime

    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3 # // is the integer division operator
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m

def main():
    while True:
        try:
            X = []
            X.append(365568744)
            X.append(495714226)
            X.append(1358608373)
            X.append(1529160998)
            X.append(822619775)
            X.append(1706525996)
            X.append(391137644)
            print '--------------'
            
            Det_X = []
            Det_X.append(calc_det(1,2,X))
            #print Det_X
            Det_X.append(calc_det(2,3,X))
            #print Det_X
            Det_X.append(calc_det(3,4,X))
            #print Det_X
            Det_X.append(calc_det(4,5,X))
            #print Det_X

            found_p = reduce(GCD, Det_X)

            # To find 'a' and 'c' we need to solve the simple equation:
            #   a = ((x3 - x4)*INVERSE_MODULE((x2-x3),p))%p
            # And:
            # c = (x4 - a*x3)%p
            # Where x2, x3, x4 are all numbers generated by the LCG that we got already!

            mod_inv_a = modInverse((X[2]-X[3]), found_p) # Here we find the modular inverse of x2-x3 with modulo p
            found_a = ((X[3] - X[4])*mod_inv_a)%found_p
            print found_a #found_a will be the correct a with high probability.

            found_c = (X[4] - found_a*X[3])%found_p
            print found_c #found_c will be the correct a with high probability, clearly depending on the correctness of a

            print "Found: %d as P, %d as a and %d as c" % (found_p, found_a, found_c)
            break
        except TypeError:
            r.close()


encrypted_secret = [
 365568652,
 495714267,
 1358608273,
 1529160966,
 822619654,
 1706526019,
 391137561,
 2076472716,
 1764278540,
 734807837,
 2073337261,
 736054556,
 2123830086,
 681801730,
 1070017952,
 1709297869,
 1046640222,
 667366781,
 58152428,
 310139563,
 640852461,
 85665152,
 1240055427,
 1907395889,
 695586467,
 750761920,
 1239683690,
 1137452295,
 1250976842,
 808635844,
 1000374841,
 777628850,
 1057483327,
 89023171,
 121647634,
 837428821,
 1438310703,
 548816510,
 558030123,
 788206776,
 562475864,
 634461615,
 834403405,
 1433232113,
 209086350,
 1784777833,
 258061229,
 1469928947,
 2076352416,
 252437757,
 598438083,
 1401155011]

def find_all():
    p = 2147483647
    c = 1
    a = 48271
    s = 1706525996
    r = ""
    for i in range(0, 46):
        s = (s * a + c) % p
        r += chr((s ^ encrypted_secret[i + 6]) % 255)
    print(r)

if __name__ == "__main__":
#    sys.exit(main())
    find_all()